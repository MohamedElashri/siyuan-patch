name: release-cron

on:
  schedule:
    - cron: "0 12 * * *"
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  create_release:
    name: get version and create release
    runs-on: ubuntu-latest
    steps:
      # FIX: Checkout is required so 'gh' knows which repo it's in
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check upstream version and whether we already have it
        id: check
        run: |
          # Fetch upstream package.json
          pkg_json=$(curl -fsSL "https://raw.githubusercontent.com/siyuan-note/siyuan/master/app/package.json")
          upstream_ver=$(echo "$pkg_json" | grep '"version"' | head -1 | awk -F: '{print $2}' | sed 's/[", ]//g')
          tag="v${upstream_ver}"
          pkg_mgr=$(echo "$pkg_json" | grep '"packageManager"' | head -1 | awk -F: '{print $2}' | sed 's/[", ]//g')

          echo "upstream_tag=${tag}" >> $GITHUB_OUTPUT
          echo "package_manager=${pkg_mgr}" >> $GITHUB_OUTPUT
          echo "Upstream version: ${tag}"

          # Check if tag exists in our repo
          # We use the API here to be faster than checking local git tags
          status_code=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/${tag}")

          if [[ "$status_code" == "200" ]]; then
            echo "Tag/release ${tag} already exists → skip."
            echo "needs_release=false" >> $GITHUB_OUTPUT
          elif [[ "$status_code" == "404" ]]; then
            echo "Tag/release ${tag} does NOT exist → will create."
            echo "needs_release=true" >> $GITHUB_OUTPUT
          else
            echo "Unexpected status: ${status_code} → aborting for safety."
            exit 1
          fi

      - name: Create Release
        if: ${{ steps.check.outputs.needs_release == 'true' }}
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ steps.check.outputs.upstream_tag }}
          name: ${{ steps.check.outputs.upstream_tag }}
          body: "Sync with upstream release"
          draft: false
          prerelease: false
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Dispatch builds
        if: ${{ steps.check.outputs.needs_release == 'true' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ver="${{ steps.check.outputs.upstream_tag }}"
          pm="${{ steps.check.outputs.package_manager }}"
          
          echo "Dispatching builds for version $ver with $pm"

          # We use the --repo flag as a double safety measure
          
          # 1. Dispatch PC
          echo "Triggering release-pc.yml..."
          gh workflow run release-pc.yml \
            --repo ${{ github.repository }} \
            --ref main \
            -f version="$ver" \
            -f packageManager="$pm"

          # 2. Dispatch Docker
          echo "Triggering release-docker.yml..."
          gh workflow run release-docker.yml \
            --repo ${{ github.repository }} \
            --ref main \
            -f version="$ver"

          # 3. Dispatch iOS (Optional - remove if not needed)
          echo "Triggering release-ios.yml..."
          gh workflow run release-ios.yml \
            --repo ${{ github.repository }} \
            --ref main \
            -f version="$ver" \
            -f packageManager="$pm" || echo "iOS workflow failed or not found (ignoring)."
